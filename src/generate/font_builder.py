"""
フォントファイル生成モジュール

生成された文字画像からTTF/OTFフォントファイルを構築する。
計画書の「8. 最終成果物の生成」に基づく実装。

処理フロー:
1. ベクター化 (Potrace): ラスター画像 → SVG
2. SVGパース: SVGパスデータを読み込み
3. グリフ格納: パスデータをフォントグリフに変換
4. メタデータ設定: フォント名、アセント/ディセント等
5. 出力: TTF/OTF
"""

import re
import subprocess
import tempfile
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from pathlib import Path

from PIL import Image

try:
    from fontTools.fontBuilder import FontBuilder as FTFontBuilder
    from fontTools.pens.t2CharStringPen import T2CharStringPen
    from fontTools.ttLib import TTFont

    FONTTOOLS_AVAILABLE = True
except ImportError:
    FONTTOOLS_AVAILABLE = False


@dataclass
class FontMetadata:
    """フォントメタデータ"""

    family_name: str = "MojaiFont"
    style_name: str = "Regular"
    version: str = "1.0"
    copyright: str = "Generated by mojai"
    designer: str = ""

    # メトリクス
    units_per_em: int = 1000
    ascender: int = 800
    descender: int = -200
    line_gap: int = 0


@dataclass
class GlyphData:
    """グリフデータ"""

    character: str
    unicode_codepoint: int
    image: Image.Image | None = None
    svg_path: str = ""
    path_commands: list = field(default_factory=list)


class SVGPathParser:
    """SVGパスパーサー"""

    @staticmethod
    def parse_svg_file(svg_path: Path) -> list[tuple]:
        """
        SVGファイルからパスコマンドを抽出

        Args:
            svg_path: SVGファイルパス

        Returns:
            パスコマンドのリスト [(command, points), ...]
        """
        try:
            tree = ET.parse(svg_path)
            root = tree.getroot()

            # SVG名前空間を処理
            ns = {"svg": "http://www.w3.org/2000/svg"}

            # pathエレメントを探す
            paths = root.findall(".//svg:path", ns)
            if not paths:
                paths = root.findall(".//path")

            all_commands = []
            for path in paths:
                d = path.get("d", "")
                commands = SVGPathParser.parse_path_data(d)
                all_commands.extend(commands)

            return all_commands

        except Exception as e:
            print(f"SVGパースエラー: {e}")
            return []

    @staticmethod
    def parse_path_data(d: str) -> list[tuple]:
        """
        SVGパスデータ文字列をパースしてコマンドリストに変換

        Args:
            d: SVGパスの'd'属性

        Returns:
            [(command, [x1, y1, ...]), ...]
        """
        commands = []

        # コマンドと数値をトークン化
        token_pattern = re.compile(r"([MLHVCSQTAZmlhvcsqtaz])|(-?\d+\.?\d*)")
        tokens = token_pattern.findall(d)

        current_command = None
        current_points = []

        for token in tokens:
            cmd, num = token

            if cmd:
                # 新しいコマンド
                if current_command:
                    commands.append((current_command, current_points))
                current_command = cmd
                current_points = []
            elif num:
                # 数値
                current_points.append(float(num))

        # 最後のコマンドを追加
        if current_command:
            commands.append((current_command, current_points))

        return commands


class FontBuilder:
    """
    フォントファイル生成クラス

    生成された文字画像群をTTF/OTFフォントファイルに変換する。
    Potraceによるベクター化とfontToolsによるフォント構築を行う。
    """

    def __init__(self, metadata: FontMetadata | None = None):
        """
        フォントビルダーを初期化

        Args:
            metadata: フォントメタデータ
        """
        self.metadata = metadata or FontMetadata()
        self._glyphs: dict[str, GlyphData] = {}
        self._svg_parser = SVGPathParser()

    def add_glyph(
        self,
        character: str,
        image: Image.Image | Path | str,
    ) -> None:
        """
        グリフを追加

        Args:
            character: Unicode文字
            image: 文字画像
        """
        if isinstance(image, (Path, str)):
            img = Image.open(image)
        else:
            img = image

        # グレースケールに変換
        if img.mode != "L":
            img = img.convert("L")

        glyph = GlyphData(
            character=character,
            unicode_codepoint=ord(character),
            image=img,
        )
        self._glyphs[character] = glyph

    def add_glyphs_from_dict(
        self,
        char_images: dict[str, Image.Image | Path | str],
    ) -> None:
        """
        複数グリフを一括追加

        Args:
            char_images: {文字: 画像} の辞書
        """
        for char, image in char_images.items():
            self.add_glyph(char, image)

    def vectorize_glyph(self, glyph: GlyphData, output_svg: Path) -> bool:
        """
        Potraceを使用してラスター画像をベクター化

        Args:
            glyph: グリフデータ
            output_svg: 出力SVGパス

        Returns:
            成功したかどうか
        """
        if glyph.image is None:
            return False

        # 一時PBMファイルを作成
        with tempfile.NamedTemporaryFile(suffix=".pbm", delete=False) as tmp:
            tmp_path = Path(tmp.name)

            # 二値化してPBM形式で保存
            binary = glyph.image.point(lambda x: 0 if x > 128 else 255, mode="1")
            binary.save(tmp_path)

        try:
            # Potraceでベクター化
            result = subprocess.run(
                [
                    "potrace",
                    "-s",  # SVG出力
                    "-t", "5",  # 許容値
                    "-o", str(output_svg),
                    str(tmp_path),
                ],
                capture_output=True,
                check=True,
            )
            glyph.svg_path = str(output_svg)

            # SVGからパスコマンドを抽出
            glyph.path_commands = self._svg_parser.parse_svg_file(output_svg)

            return True

        except subprocess.CalledProcessError as e:
            print(f"Potraceエラー: {e.stderr.decode() if e.stderr else e}")
            return self._fallback_vectorize(glyph, output_svg)

        except FileNotFoundError:
            print("Potraceが見つかりません。フォールバック処理を使用します。")
            return self._fallback_vectorize(glyph, output_svg)

        finally:
            tmp_path.unlink(missing_ok=True)

    def _fallback_vectorize(self, glyph: GlyphData, output_svg: Path) -> bool:
        """
        Potraceが利用できない場合のフォールバック

        輪郭検出を使用してSVGを生成する。
        """
        if glyph.image is None:
            return False

        import cv2
        import numpy as np

        # numpy配列に変換
        img_array = np.array(glyph.image)

        # 二値化
        _, binary = cv2.threshold(img_array, 128, 255, cv2.THRESH_BINARY_INV)

        # 輪郭検出
        contours, hierarchy = cv2.findContours(
            binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE
        )

        # SVGを生成
        width, height = glyph.image.size
        svg_paths = []

        for contour in contours:
            if len(contour) < 3:
                continue

            points = contour.squeeze()
            if len(points.shape) == 1:
                continue

            # パスデータを構築
            path_data = f"M {points[0][0]} {points[0][1]} "
            for point in points[1:]:
                path_data += f"L {point[0]} {point[1]} "
            path_data += "Z"

            svg_paths.append(path_data)

        if not svg_paths:
            # 輪郭がない場合は矩形を生成
            svg_paths.append(f"M 10 10 L {width-10} 10 L {width-10} {height-10} L 10 {height-10} Z")

        svg_content = f"""<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}" viewBox="0 0 {width} {height}">
"""
        for path_data in svg_paths:
            svg_content += f'  <path d="{path_data}" fill="black"/>\n'
        svg_content += "</svg>"

        output_svg.write_text(svg_content)
        glyph.svg_path = str(output_svg)

        # パスコマンドを解析
        glyph.path_commands = []
        for path_data in svg_paths:
            commands = self._svg_parser.parse_path_data(path_data)
            glyph.path_commands.extend(commands)

        return True

    def build(self, output_path: Path | str) -> Path:
        """
        フォントファイルを生成

        Args:
            output_path: 出力ファイルパス (.ttf または .otf)

        Returns:
            生成されたフォントファイルのパス
        """
        output_path = Path(output_path)

        if not FONTTOOLS_AVAILABLE:
            raise RuntimeError(
                "fontToolsがインストールされていません。"
                "'pip install fonttools' を実行してください。"
            )

        # 一時ディレクトリでSVGを生成
        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_path = Path(tmp_dir)

            # 全グリフをベクター化
            for char, glyph in self._glyphs.items():
                svg_path = tmp_path / f"U+{ord(char):04X}.svg"
                self.vectorize_glyph(glyph, svg_path)

            # フォントを構築
            return self._build_font(output_path)

    def _build_font(self, output_path: Path) -> Path:
        """
        fontToolsを使用してフォントファイルを構築
        """
        is_ttf = output_path.suffix.lower() == ".ttf"

        # 基本フォント構造を作成
        fb = FTFontBuilder(self.metadata.units_per_em, isTTF=is_ttf)

        # グリフ名マッピング
        glyph_order = [".notdef", "space"]
        cmap = {32: "space"}  # スペース

        for char, glyph in self._glyphs.items():
            glyph_name = f"uni{glyph.unicode_codepoint:04X}"
            glyph_order.append(glyph_name)
            cmap[glyph.unicode_codepoint] = glyph_name

        fb.setupGlyphOrder(glyph_order)
        fb.setupCharacterMap(cmap)

        # メタデータ設定
        fb.setupNameTable({
            "familyName": self.metadata.family_name,
            "styleName": self.metadata.style_name,
            "version": f"Version {self.metadata.version}",
            "copyright": self.metadata.copyright,
        })

        # メトリクス設定
        fb.setupHead(unitsPerEm=self.metadata.units_per_em)
        fb.setupHhea(
            ascent=self.metadata.ascender,
            descent=self.metadata.descender,
            lineGap=self.metadata.line_gap,
        )

        # グリフの幅を設定
        advance_widths = {
            ".notdef": self.metadata.units_per_em // 2,
            "space": self.metadata.units_per_em // 2,
        }
        for glyph_name in glyph_order[2:]:
            advance_widths[glyph_name] = self.metadata.units_per_em

        fb.setupHmtx(advance_widths)

        # グリフアウトラインを構築
        if is_ttf:
            self._build_ttf_glyphs(fb, glyph_order)
        else:
            self._build_cff_glyphs(fb, glyph_order)

        fb.setupOS2()
        fb.setupPost()

        # ファイルに保存
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fb.font.save(str(output_path))

        return output_path

    def _build_ttf_glyphs(self, fb: FTFontBuilder, glyph_order: list[str]) -> None:
        """TTF形式のグリフを構築 (TrueType outlines)"""
        from fontTools.pens.t2CharStringPen import T2CharStringPen
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        pen = {}

        # .notdef と space
        pen[".notdef"] = self._create_notdef_glyph()
        pen["space"] = Glyph()

        # 各グリフを構築
        for glyph_name in glyph_order[2:]:
            char = chr(int(glyph_name[3:], 16))
            if char in self._glyphs:
                glyph = self._glyphs[char]
                pen[glyph_name] = self._path_to_ttf_glyph(glyph)
            else:
                pen[glyph_name] = Glyph()

        fb.setupGlyf(pen)

    def _build_cff_glyphs(self, fb: FTFontBuilder, glyph_order: list[str]) -> None:
        """CFF形式のグリフを構築 (PostScript outlines)"""
        charstrings = {}

        # .notdef
        pen = T2CharStringPen(self.metadata.units_per_em, None)
        pen.moveTo((100, 0))
        pen.lineTo((100, 700))
        pen.lineTo((400, 700))
        pen.lineTo((400, 0))
        pen.closePath()
        charstrings[".notdef"] = pen.getCharString()

        # space
        pen = T2CharStringPen(self.metadata.units_per_em, None)
        charstrings["space"] = pen.getCharString()

        # 各グリフを構築
        for glyph_name in glyph_order[2:]:
            char = chr(int(glyph_name[3:], 16))
            if char in self._glyphs:
                glyph = self._glyphs[char]
                charstrings[glyph_name] = self._path_to_cff_charstring(glyph)
            else:
                pen = T2CharStringPen(self.metadata.units_per_em, None)
                charstrings[glyph_name] = pen.getCharString()

        fb.setupCFF(
            nameStrings={"familyName": self.metadata.family_name},
            charStringsDict=charstrings,
            privateDict={},
        )

    def _create_notdef_glyph(self):
        """notdefグリフを作成"""
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        glyph = Glyph()
        glyph.numberOfContours = 1

        # 単純な矩形
        glyph.coordinates = [(100, 0), (400, 0), (400, 700), (100, 700)]
        glyph.flags = [1, 1, 1, 1]
        glyph.endPtsOfContours = [3]

        glyph.program = None

        return glyph

    def _path_to_ttf_glyph(self, glyph_data: GlyphData):
        """パスコマンドからTTFグリフを作成"""
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        glyph = Glyph()

        if not glyph_data.path_commands:
            return glyph

        # パスコマンドを座標に変換
        coordinates = []
        flags = []
        end_pts = []

        current_x, current_y = 0.0, 0.0
        scale = self.metadata.units_per_em / 64.0  # 64px -> units_per_em

        for cmd, points in glyph_data.path_commands:
            if cmd in ("M", "m"):
                # Move to
                if coordinates and end_pts and end_pts[-1] != len(coordinates) - 1:
                    end_pts.append(len(coordinates) - 1)

                if len(points) >= 2:
                    if cmd == "m":
                        current_x += points[0]
                        current_y += points[1]
                    else:
                        current_x, current_y = points[0], points[1]

                    # Y座標を反転（SVGは上が0、フォントは下が0）
                    x = int(current_x * scale)
                    y = int((64 - current_y) * scale)
                    coordinates.append((x, y))
                    flags.append(1)

            elif cmd in ("L", "l"):
                # Line to
                i = 0
                while i < len(points) - 1:
                    if cmd == "l":
                        current_x += points[i]
                        current_y += points[i + 1]
                    else:
                        current_x, current_y = points[i], points[i + 1]

                    x = int(current_x * scale)
                    y = int((64 - current_y) * scale)
                    coordinates.append((x, y))
                    flags.append(1)
                    i += 2

            elif cmd in ("Z", "z"):
                # Close path
                if coordinates:
                    end_pts.append(len(coordinates) - 1)

        if not coordinates:
            return glyph

        # 最後のパスを閉じる
        if not end_pts or end_pts[-1] != len(coordinates) - 1:
            end_pts.append(len(coordinates) - 1)

        glyph.numberOfContours = len(end_pts)
        glyph.coordinates = coordinates
        glyph.flags = flags
        glyph.endPtsOfContours = end_pts
        glyph.program = None

        return glyph

    def _path_to_cff_charstring(self, glyph_data: GlyphData):
        """パスコマンドからCFF CharStringを作成"""
        pen = T2CharStringPen(self.metadata.units_per_em, None)

        if not glyph_data.path_commands:
            return pen.getCharString()

        current_x, current_y = 0.0, 0.0
        scale = self.metadata.units_per_em / 64.0

        for cmd, points in glyph_data.path_commands:
            if cmd in ("M", "m"):
                if len(points) >= 2:
                    if cmd == "m":
                        current_x += points[0]
                        current_y += points[1]
                    else:
                        current_x, current_y = points[0], points[1]

                    x = current_x * scale
                    y = (64 - current_y) * scale
                    pen.moveTo((x, y))

            elif cmd in ("L", "l"):
                i = 0
                while i < len(points) - 1:
                    if cmd == "l":
                        current_x += points[i]
                        current_y += points[i + 1]
                    else:
                        current_x, current_y = points[i], points[i + 1]

                    x = current_x * scale
                    y = (64 - current_y) * scale
                    pen.lineTo((x, y))
                    i += 2

            elif cmd in ("C", "c"):
                i = 0
                while i < len(points) - 5:
                    if cmd == "c":
                        x1 = (current_x + points[i]) * scale
                        y1 = (64 - (current_y + points[i + 1])) * scale
                        x2 = (current_x + points[i + 2]) * scale
                        y2 = (64 - (current_y + points[i + 3])) * scale
                        current_x += points[i + 4]
                        current_y += points[i + 5]
                    else:
                        x1 = points[i] * scale
                        y1 = (64 - points[i + 1]) * scale
                        x2 = points[i + 2] * scale
                        y2 = (64 - points[i + 3]) * scale
                        current_x, current_y = points[i + 4], points[i + 5]

                    x = current_x * scale
                    y = (64 - current_y) * scale
                    pen.curveTo((x1, y1), (x2, y2), (x, y))
                    i += 6

            elif cmd in ("Z", "z"):
                pen.closePath()

        return pen.getCharString()
