"""
ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«æ§‹ç¯‰ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼

ç”Ÿæˆã•ã‚ŒãŸã‚°ãƒªãƒ•ç”»åƒï¼ˆãƒ©ã‚¹ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼‰ã‚’ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ã—ï¼Œ
fontTools ãƒ©ã‚¤ãƒ–ãƒªã‚’ç”¨ã„ã¦ TrueTypeï¼ˆTTFï¼‰ã¾ãŸã¯ OpenTypeï¼ˆOTF/CFFï¼‰å½¢å¼ã®
ãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ§‹ç¯‰ã™ã‚‹ï¼
"""

import re
import subprocess
import tempfile
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from pathlib import Path

from PIL import Image

try:
    from fontTools.fontBuilder import FontBuilder as FTFontBuilder
    from fontTools.pens.t2CharStringPen import T2CharStringPen
    from fontTools.ttLib import TTFont

    FONTTOOLS_AVAILABLE = True
except ImportError:
    FONTTOOLS_AVAILABLE = False


@dataclass
class FontMetadata:
    """ãƒ•ã‚©ãƒ³ãƒˆã®åç§°ã‚„ãƒ¡ãƒˆãƒªã‚¯ã‚¹æƒ…å ±ã‚’ä¿æŒã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼"""

    family_name: str = "MojaiFont"
    style_name: str = "Regular"
    version: str = "1.0"
    copyright: str = "Generated by mojai"
    designer: str = ""

    # ãƒ•ã‚©ãƒ³ãƒˆãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®å®šç¾©ï¼ˆæ¨™æº–çš„ãª 1000 units/em æ§‹æˆï¼‰
    units_per_em: int = 1000
    ascender: int = 800
    descender: int = -200
    line_gap: int = 0


@dataclass
class GlyphData:
    """å€‹åˆ¥ã®ã‚°ãƒªãƒ•ï¼ˆæ–‡å­—ï¼‰ã«é–¢ã™ã‚‹æƒ…å ±ã‚’ä¿æŒã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒ©ã‚¹ï¼"""

    character: str
    unicode_codepoint: int
    image: Image.Image | None = None
    svg_path: str = ""
    path_commands: list = field(default_factory=list)


class SVGPathParser:
    """
    SVG ãƒ‘ã‚¹ãƒ‡ãƒ¼ã‚¿ã®è§£æã‚’æ‹…å½“ã™ã‚‹ã‚¯ãƒ©ã‚¹ï¼

    Potrace ç­‰ã§ç”Ÿæˆã•ã‚ŒãŸ SVG ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ 'd' å±æ€§ã®ãƒ‘ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡ºãƒ»ãƒˆãƒ¼ã‚¯ãƒ³åŒ–ã™ã‚‹ï¼
    """

    @staticmethod
    def parse_svg_file(svg_path: Path) -> list[tuple]:
        """
        SVG ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ‘ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’æŠ½å‡ºã™ã‚‹ï¼

        Args:
            svg_path (Path): å…¥åŠ› SVG ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ï¼

        Returns:
            list[tuple]: ã‚³ãƒãƒ³ãƒ‰ã¨åº§æ¨™ã®ãƒªã‚¹ãƒˆ [(command, points), ...]ï¼
        """
        try:
            tree = ET.parse(svg_path)
            root = tree.getroot()

            # XML åå‰ç©ºé–“ã®è€ƒæ…®
            ns = {"svg": "http://www.w3.org/2000/svg"}

            # <path> ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆã®æ¤œç´¢
            paths = root.findall(".//svg:path", ns)
            if not paths:
                paths = root.findall(".//path")

            all_commands = []
            for path in paths:
                d = path.get("d", "")
                commands = SVGPathParser.parse_path_data(d)
                all_commands.extend(commands)

            return all_commands

        except Exception as e:
            print(f"âš ï¸ SVG parsing error: {e}")
            return []

    @staticmethod
    def parse_path_data(d: str) -> list[tuple]:
        """
        SVG ãƒ‘ã‚¹æ–‡å­—åˆ—ï¼ˆdå±æ€§ï¼‰ã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ï¼Œæ§‹é€ åŒ–ã•ã‚ŒãŸã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«å¤‰æ›ã™ã‚‹ï¼
        """
        commands = []

        # ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆï¼ˆã‚³ãƒãƒ³ãƒ‰ï¼‰ã¨æ•°å€¤ï¼ˆåº§æ¨™ï¼‰ã‚’æŠ½å‡º
        token_pattern = re.compile(r"([MLHVCSQTAZmlhvcsqtaz])|(-?\d+\.?\d*)")
        tokens = token_pattern.findall(d)

        current_command = None
        current_points = []

        for token in tokens:
            cmd, num = token
            if cmd:
                if current_command:
                    commands.append((current_command, current_points))
                current_command = cmd
                current_points = []
            elif num:
                current_points.append(float(num))

        if current_command:
            commands.append((current_command, current_points))

        return commands


class FontBuilder:
    """
    ãƒ•ã‚©ãƒ³ãƒˆæ§‹ç¯‰ã‚¨ãƒ³ã‚¸ãƒ³ã‚¯ãƒ©ã‚¹ï¼

    Potrace ã«ã‚ˆã‚‹ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ãƒ—ãƒ­ã‚»ã‚¹ã¨ï¼ŒfontTools ã‚’ç”¨ã„ãŸãƒã‚¤ãƒŠãƒªæ§‹ç¯‰ã‚’çµ±æ‹¬ã™ã‚‹ï¼
    """

    def __init__(self, metadata: FontMetadata | None = None):
        """
        ãƒ•ã‚©ãƒ³ãƒˆãƒ“ãƒ«ãƒ€ãƒ¼ã‚’åˆæœŸåŒ–ã™ã‚‹ï¼

        Args:
            metadata (FontMetadata, optional): ãƒ•ã‚©ãƒ³ãƒˆåç­‰ã®å®šç¾©æƒ…å ±ï¼
        """
        self.metadata = metadata or FontMetadata()
        self._glyphs: dict[str, GlyphData] = {}
        self._svg_parser = SVGPathParser()

    def add_glyph(self, character: str, image: Image.Image | Path | str) -> None:
        """
        ç‰¹å®šã®æ–‡å­—ã¨ç”»åƒã®ãƒšã‚¢ã‚’ã‚°ãƒªãƒ•ãƒªã‚¹ãƒˆã«è¿½åŠ ã™ã‚‹ï¼
        """
        if isinstance(image, (Path, str)):
            img = Image.open(image)
        else:
            img = image

        if img.mode != "L":
            img = img.convert("L")

        glyph = GlyphData(
            character=character,
            unicode_codepoint=ord(character),
            image=img,
        )
        self._glyphs[character] = glyph

    def vectorize_glyph(self, glyph: GlyphData, output_svg: Path) -> bool:
        """
        å¤–éƒ¨ãƒ„ãƒ¼ãƒ« Potrace ã‚’å‘¼ã³å‡ºã—ï¼Œã‚°ãƒªãƒ•ç”»åƒã‚’ãƒ™ã‚¯ã‚¿ãƒ¼å½¢å¼ï¼ˆSVGï¼‰ã«å¤‰æ›ã™ã‚‹ï¼

        Potrace ãŒåˆ©ç”¨ã§ããªã„å ´åˆã¯ï¼Œè‡ªå‹•çš„ã« OpenCV ãƒ™ãƒ¼ã‚¹ã®è¼ªéƒ­æŠ½å‡ºãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ï¼
        """
        if glyph.image is None:
            return False

        # Potrace ã¯ PBM å½¢å¼ã‚’è¦æ±‚ã™ã‚‹ãŸã‚ï¼Œä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹
        with tempfile.NamedTemporaryFile(suffix=".pbm", delete=False) as tmp:
            tmp_path = Path(tmp.name)
            # 128 ã‚’é–¾å€¤ã¨ã—ã¦äºŒå€¤åŒ–ã—ï¼ŒPBM(mode="1") ã§ä¿å­˜
            binary = glyph.image.point(lambda x: 0 if x > 128 else 255, mode="1")
            binary.save(tmp_path)

        try:
            # Potrace ã®å®Ÿè¡Œ: SVG å‡ºåŠ›ï¼Œå¹³æ»‘åŒ–é–¾å€¤ãªã©ã®æœ€é©åŒ–å¼•æ•°ã‚’æŒ‡å®š
            subprocess.run(
                [
                    "potrace",
                    "-s",  # SVG å‡ºåŠ›ãƒ¢ãƒ¼ãƒ‰
                    "-t",
                    "5",  # è¨±å®¹å…¬å·®
                    "-o",
                    str(output_svg),
                    str(tmp_path),
                ],
                capture_output=True,
                check=True,
            )
            glyph.svg_path = str(output_svg)
            glyph.path_commands = self._svg_parser.parse_svg_file(output_svg)
            return True

        except (subprocess.CalledProcessError, FileNotFoundError):
            # Potrace æœªã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ç­‰ã®å ´åˆã¯ OpenCV ã§ä»£ç”¨
            return self._fallback_vectorize(glyph, output_svg)

        finally:
            tmp_path.unlink(missing_ok=True)

    def _fallback_vectorize(self, glyph: GlyphData, output_svg: Path) -> bool:
        """OpenCV ã®è¼ªéƒ­æ¤œå‡ºã‚’ç”¨ã„ãŸï¼Œã‚·ãƒ³ãƒ—ãƒ«ãªãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼"""
        import cv2
        import numpy as np

        img_array = np.array(glyph.image)
        _, binary = cv2.threshold(img_array, 128, 255, cv2.THRESH_BINARY_INV)

        # è¼ªéƒ­ï¼ˆContoursï¼‰ã®æŠ½å‡º
        contours, _ = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

        width, height = glyph.image.size
        svg_paths = []

        for contour in contours:
            if len(contour) < 3:
                continue
            points = contour.squeeze()
            if len(points.shape) == 1:
                continue

            # ç›´ç·šï¼ˆLï¼‰ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹ãƒ‘ã‚¹å½¢æˆ
            path_data = f"M {points[0][0]} {points[0][1]} "
            for point in points[1:]:
                path_data += f"L {point[0]} {point[1]} "
            path_data += "Z"
            svg_paths.append(path_data)

        # SVG æ–‡å­—åˆ—ã®æ§‹ç¯‰
        svg_content = f'<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}" viewBox="0 0 {width} {height}">\n'
        for path_data in svg_paths:
            svg_content += f'  <path d="{path_data}" fill="black"/>\n'
        svg_content += "</svg>"

        output_svg.write_text(svg_content)
        glyph.svg_path = str(output_svg)

        glyph.path_commands = []
        for path_data in svg_paths:
            glyph.path_commands.extend(self._svg_parser.parse_path_data(path_data))

        return True

    def build(self, output_path: Path | str) -> Path:
        """
        è“„ç©ã•ã‚ŒãŸå…¨ã‚°ãƒªãƒ•ã‚’ã¾ã¨ã‚ï¼Œãƒã‚¤ãƒŠãƒªãƒ•ã‚©ãƒ³ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã™ã‚‹ï¼
        """
        output_path = Path(output_path)
        if not FONTTOOLS_AVAILABLE:
            raise RuntimeError("fontTools library is not installed.")

        # ä½œæ¥­ç”¨ã®ä¸€æ™‚ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã§ãƒ™ã‚¯ã‚¿ãƒ¼åŒ–ã‚’å…¨æ–‡å­—å®Ÿè¡Œ
        with tempfile.TemporaryDirectory() as tmp_dir:
            tmp_path = Path(tmp_dir)
            for char, glyph in self._glyphs.items():
                svg_path = tmp_path / f"U+{ord(char):04X}.svg"
                self.vectorize_glyph(glyph, svg_path)

            return self._build_font(output_path)

    def _build_font(self, output_path: Path) -> Path:
        """fontTools ãƒ©ã‚¤ãƒ–ãƒªã‚’ç”¨ã„ã¦ï¼Œå„ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¨­å®šã—ãƒ•ã‚©ãƒ³ãƒˆã‚’ãƒã‚¤ãƒŠãƒªåŒ–ã™ã‚‹ï¼"""
        is_ttf = output_path.suffix.lower() == ".ttf"

        # FontBuilder ã®åˆæœŸåŒ–ï¼ˆunits/em æŒ‡å®šï¼‰
        fb = FTFontBuilder(self.metadata.units_per_em, isTTF=is_ttf)

        # ã‚°ãƒªãƒ•ã‚»ãƒƒãƒˆã¨ Unicode ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆcmapï¼‰ã®å®šç¾©
        glyph_order = [".notdef", "space"]
        cmap = {32: "space"}

        for char, glyph in self._glyphs.items():
            glyph_name = f"uni{glyph.unicode_codepoint:04X}"
            glyph_order.append(glyph_name)
            cmap[glyph.unicode_codepoint] = glyph_name

        fb.setupGlyphOrder(glyph_order)
        fb.setupCharacterMap(cmap)

        # ãƒ•ã‚©ãƒ³ãƒˆåç§°ï¼ˆname ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã®è¨­å®š
        fb.setupNameTable(
            {
                "familyName": self.metadata.family_name,
                "styleName": self.metadata.style_name,
                "version": f"Version {self.metadata.version}",
                "copyright": self.metadata.copyright,
            }
        )

        # ãƒ¡ãƒˆãƒªã‚¯ã‚¹æƒ…å ±ã®åæ˜ 
        fb.setupHead(unitsPerEm=self.metadata.units_per_em)
        fb.setupHhea(
            ascent=self.metadata.ascender,
            descent=self.metadata.descender,
            lineGap=self.metadata.line_gap,
        )

        # æ–‡å­—å¹…ï¼ˆhmtx ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰ã®ä¸€æ‹¬è¨­å®š
        advance_widths = {
            name: (
                self.metadata.units_per_em // 2
                if name in (".notdef", "space")
                else self.metadata.units_per_em
            )
            for name in glyph_order
        }
        fb.setupHmtx(advance_widths)

        # ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆglyf / CFFï¼‰ã®æ§‹ç¯‰
        if is_ttf:
            self._build_ttf_glyphs(fb, glyph_order)
        else:
            self._build_cff_glyphs(fb, glyph_order)

        fb.setupOS2()
        fb.setupPost()

        # å‡ºåŠ›
        output_path.parent.mkdir(parents=True, exist_ok=True)
        fb.font.save(str(output_path))
        print(f"ğŸ“¦ Font built successfully: {output_path}")

        return output_path

    def _build_ttf_glyphs(self, fb: FTFontBuilder, glyph_order: list[str]) -> None:
        """TrueType ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆQuadratic curvesï¼‰å½¢å¼ã§ã‚°ãƒªãƒ•ã‚’æ§‹ç¯‰ã™ã‚‹ï¼"""
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        pen_data = {".notdef": self._create_notdef_glyph(), "space": Glyph()}

        for glyph_name in glyph_order[2:]:
            char = chr(int(glyph_name[3:], 16))
            glyph = self._glyphs.get(char)
            pen_data[glyph_name] = self._path_to_ttf_glyph(glyph) if glyph else Glyph()

        fb.setupGlyf(pen_data)

    def _build_cff_glyphs(self, fb: FTFontBuilder, glyph_order: list[str]) -> None:
        """PostScript/CFF ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼ˆCubic curvesï¼‰å½¢å¼ã§ã‚°ãƒªãƒ•ã‚’æ§‹ç¯‰ã™ã‚‹ï¼"""
        charstrings = {}

        # .notdef ã®æç”»
        pen = T2CharStringPen(self.metadata.units_per_em, None)
        pen.rect(100, 0, 300, 700)
        charstrings[".notdef"] = pen.getCharString()

        # space ã®æç”»ï¼ˆç©ºï¼‰
        pen = T2CharStringPen(self.metadata.units_per_em, None)
        charstrings["space"] = pen.getCharString()

        for glyph_name in glyph_order[2:]:
            char = chr(int(glyph_name[3:], 16))
            glyph = self._glyphs.get(char)
            charstrings[glyph_name] = (
                self._path_to_cff_charstring(glyph)
                if glyph
                else T2CharStringPen(self.metadata.units_per_em, None).getCharString()
            )

        fb.setupCFF(
            nameStrings={"familyName": self.metadata.family_name},
            charStringsDict=charstrings,
            privateDict={},
        )

    def _create_notdef_glyph(self):
        """ãƒ•ã‚©ãƒ³ãƒˆã«æœªå¯¾å¿œæ–‡å­—ãŒå«ã¾ã‚Œã‚‹éš›ã«è¡¨ç¤ºã•ã‚Œã‚‹çŸ©å½¢ã‚°ãƒªãƒ•ã‚’ä½œæˆã™ã‚‹ï¼"""
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        glyph = Glyph()
        glyph.numberOfContours = 1
        glyph.coordinates = [(100, 0), (400, 0), (400, 700), (100, 700)]
        glyph.flags = [1, 1, 1, 1]
        glyph.endPtsOfContours = [3]
        return glyph

    def _path_to_ttf_glyph(self, glyph_data: GlyphData):
        """SVG ãƒ‘ã‚¹ã‚’ TrueType ã‚°ãƒªãƒ•å½¢å¼ï¼ˆåº§æ¨™åè»¢ãŠã‚ˆã³ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ï¼‰ã«å¤‰æ›ã™ã‚‹ï¼"""
        from fontTools.ttLib.tables._g_l_y_f import Glyph

        glyph = Glyph()
        if not glyph_data.path_commands:
            return glyph

        coordinates, flags, end_pts = [], [], []
        current_x, current_y = 0.0, 0.0
        # ç”»åƒè§£åƒåº¦ï¼ˆ64pxï¼‰ã‹ã‚‰ãƒ•ã‚©ãƒ³ãƒˆãƒ¦ãƒ‹ãƒƒãƒˆï¼ˆunits_per_emï¼‰ã¸ã®å¤‰æ›å€ç‡
        scale = self.metadata.units_per_em / 64.0

        for cmd, points in glyph_data.path_commands:
            if cmd in ("M", "m"):
                if coordinates and (not end_pts or end_pts[-1] != len(coordinates) - 1):
                    end_pts.append(len(coordinates) - 1)

                if len(points) >= 2:
                    if cmd == "m":
                        current_x += points[0]
                        current_y += points[1]
                    else:
                        current_x, current_y = points[0], points[1]

                    # åº§æ¨™ç³»ã®å¤‰æ›: SVG (ä¸ŠåŸç‚¹) -> Font (ä¸‹åŸç‚¹)
                    coordinates.append((int(current_x * scale), int((64 - current_y) * scale)))
                    flags.append(1)

            elif cmd in ("L", "l"):
                i = 0
                while i < len(points) - 1:
                    if cmd == "l":
                        current_x += points[i]
                        current_y += points[i + 1]
                    else:
                        current_x, current_y = points[i], points[i + 1]

                    coordinates.append((int(current_x * scale), int((64 - current_y) * scale)))
                    flags.append(1)
                    i += 2

            elif cmd in ("Z", "z"):
                if coordinates:
                    end_pts.append(len(coordinates) - 1)

        if not coordinates:
            return glyph

        if not end_pts or end_pts[-1] != len(coordinates) - 1:
            end_pts.append(len(coordinates) - 1)

        glyph.numberOfContours = len(end_pts)
        glyph.coordinates = coordinates
        glyph.flags = flags
        glyph.endPtsOfContours = end_pts
        return glyph

    def _path_to_cff_charstring(self, glyph_data: GlyphData):
        """SVG ãƒ‘ã‚¹ã‚’ CFF CharStringï¼ˆPostScript ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ï¼‰ã«å¤‰æ›ã™ã‚‹ï¼"""
        pen = T2CharStringPen(self.metadata.units_per_em, None)
        if not glyph_data.path_commands:
            return pen.getCharString()

        current_x, current_y = 0.0, 0.0
        scale = self.metadata.units_per_em / 64.0

        for cmd, points in glyph_data.path_commands:
            if cmd in ("M", "m"):
                if len(points) >= 2:
                    if cmd == "m":
                        current_x += points[0]
                        current_y += points[1]
                    else:
                        current_x, current_y = points[0], points[1]
                    pen.moveTo((current_x * scale, (64 - current_y) * scale))

            elif cmd in ("L", "l"):
                i = 0
                while i < len(points) - 1:
                    if cmd == "l":
                        current_x += points[i]
                        current_y += points[i + 1]
                    else:
                        current_x, current_y = points[i], points[i + 1]
                    pen.lineTo((current_x * scale, (64 - current_y) * scale))
                    i += 2

            elif cmd in ("C", "c"):
                # ãƒ™ã‚¸ã‚§æ›²ç·šã®æç”»
                i = 0
                while i < len(points) - 5:
                    if cmd == "c":
                        pts = [
                            (
                                (current_x + points[i + j]) * scale,
                                (64 - (current_y + points[i + j + 1])) * scale,
                            )
                            for j in range(0, 6, 2)
                        ]
                        current_x += points[i + 4]
                        current_y += points[i + 5]
                    else:
                        pts = [
                            (points[i + j] * scale, (64 - points[i + j + 1]) * scale)
                            for j in range(0, 6, 2)
                        ]
                        current_x, current_y = points[i + 4], points[i + 5]

                    pen.curveTo(*pts)
                    i += 6

            elif cmd in ("Z", "z"):
                pen.closePath()

        return pen.getCharString()
